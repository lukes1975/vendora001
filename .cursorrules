APPLICATION OVERVIEW (FCMCS MOBILE FINANCIAL PORTAL):

- This project is a READ-ONLY mobile financial portal.
- It does NOT modify, delete, or create financial records.
- It acts as a secure data proxy over a legacy MSSQL (VB.NET) system.

ARCHITECTURE:
- Frontend: React Native (Rork)
- Backend: Node.js + Express (API Bridge)
- Database: MSSQL (legacy, source of truth)

DATA FLOW (STRICT):
1. Mobile app NEVER connects directly to MSSQL
2. All requests go through the Node.js API
3. API performs:
   - Authentication
   - Data filtering
   - Data transformation
4. API returns clean JSON to the mobile app

SECURITY RULES:
- HTTPS only
- Read-only SQL queries
- No INSERT / UPDATE / DELETE on financial tables
- Use parameterized SQL queries ONLY
- Credentials stored in .env

RESPONSIBILITY SPLIT:
- Frontend: UI, animations, state, API calls
- Backend: auth, validation, SQL queries, data shaping
- Database: untouched legacy system

# LOGIN / AUTH IMPLEMENTATION
AUTHENTICATION STRATEGY (AUTHORITATIVE):

- DO NOT use the legacy encrypted Password column
- Mobile authentication uses a NEW column: Passcode
- Legacy Password column must remain untouched

PASSCODE RULES:
- Default passcode = member phone number(already stored in the passcode column)
- Passcode is stored as a bcrypt HASH
- Comparison must use bcrypt.compare()

LOGIN INPUT FORMAT:
- Frontend sends username as: "IPPIS/PL"
  Example: "TI9875/2432"

USERNAME PARSING:
1. Split username by "/"
2. Ignore IPPIS value
3. Use PL number as the authoritative identifier

DATABASE LOOKUP RULE:
-auth table in db: Internetclients
- UserName column format in DB:
  "IPPIS/PL;EMAIL"
- SQL lookup MUST use:
  WHERE UserName LIKE '%/PL;%'
- NEVER perform exact UserName match

LOGIN FLOW (auth.js):
1. Parse PL from username
2. Fetch user row by PL
3. Compare input passcode with stored bcrypt hash
4. On success, return minimal user identity payload
5. Grant read-only access

OPTIONAL:
- On first login, force passcode change

# PROJECT STRUCTURE
/fcmcs-backend
├── /routes
│   ├── auth.js        // login, PL parsing, bcrypt passcode auth
│   └── dashboard.js  // shares, savings, loans (read-only)
├── /services
│   └── db.js         // MSSQL connection pool
├── .env              // DB + secrets
├── index.js          // Express bootstrap (Plesk entry)
├── package.json      // express, mssql, bcrypt, dotenv
└── .cursorrules      // SINGLE SOURCE OF TRUTH FOR AI

PASSCODE MANAGEMENT RULES (FCMCS MOBILE FINANCIAL PORTAL):

1. GENERAL PRINCIPLES
- All passcode logic uses the NEW `Passcode` column ONLY (legacy Password untouched)
- All passcodes are stored as bcrypt hashes
- Backend must use parameterized queries
- Rate-limit endpoints to prevent abuse
- HTTPS mandatory

2. FORGOT PASSCODE (OTP-BASED, NON-DESTRUCTIVE)

Endpoint:
POST /api/auth/forgot-passcode

Rules Cursor MUST follow:

Accept username in format IPPIS/PL

Parse and extract PL

Look up user by PL

Generate 6-digit numeric OTP

bcrypt-hash OTP

Store ONLY in:

ResetOTPHash

ResetOTPExpiresAt (10 minutes)

DO NOT modify:

Passcode

Password

Send OTP to user email column using Resend API

Always return generic response (no user existence leak)

Forbidden:

Do NOT send passcode

Do NOT overwrite passcode

Do NOT auto-login

Do NOT issue JWT

Response:

{
  "success": true,
  "message": "If the account exists, a reset code has been sent."
}


3. RESET PASSCODE
- Endpoint: POST /api/auth/reset-passcode
- Input: { "token": JWT, "oldPasscode": "...", "newPasscode": "..." }
- Flow:
  1. Verify JWT token to get user PL
  2. Compare oldPasscode with Passcode hash
  3. Validate newPasscode (min 6 chars, not equal to phone number)
  4. Hash newPasscode with bcrypt
  5. Update Passcode column and PasscodeUpdatedAt
- Response: success message

4. RESEND FORGOT PASSCODE
- Endpoint: POST /api/auth/resend-passcode
- Input: { "username": "IPPIS/PL" }
- Flow:
  1. Lookup user by PL
  2. Fetch the last temporary passcode (if exists and still valid)
  3. Resend via email
- Response: success message
- No new passcode is generated unless the old one has expired

5. SECURITY NOTES
- Temporary passcodes expire in 30 minutes
- Limit resend to 3 per hour per user
- All endpoints are read-only except Passcode updates
- Return generic messages to avoid user enumeration

FCMCS DASHBOARD RULES (STRICT)

ENDPOINT
- Route: GET /api/dashboard
- Auth: JWT required
- Source of truth for member identity: req.user.pl ONLY
- Do NOT accept PL from params, query, or body

DATABASE
- Table: Pix_Table
- Member key: AdNo = pl
- Use MSSQL parameterized queries only

COLUMNS MAPPING
- Shares → ShrBal = ISNULL(ShrsBal, 0)
- OrdinarySavings → SavingBal = ISNULL(SavingBal, 0)
- RefundAccount → RefundAccount = ISNULL(BuildBal, 0)
- RSSAccount → RSSAccount = ISNULL(SpeSavBal, 0)
- CommodityAccount → CommodityAccount = ISNULL(EssenCoRepBal, 0)
- DevelopmentLevy → DevelopmentLevy = ISNULL(DevBal, 0)
- Loans → Loans = ISNULL(LoanRepBal, 0)

CALCULATIONS (BACKEND ONLY)
- totalAssets =
    Shares +
    OrdinarySavings +
    RefundAccount +
    RSSAccount +
- totalLiability = Loans + CommodityAccount
- netBalance = totalAssets - totalLiability

RESPONSE RULES
- Return numbers only (no strings)
- Do NOT return raw DB column names
- Response shape must be flat and frontend-ready

RESPONSE FORMAT
{
  "success": true,
  "data": {
    "shares": number,
    "ordinarySavings": number,
    "refundAccount": number,
    "rssAccount": number,
    "commodityAccount": number,
    "developmentLevy": number,
    "loans": number,
    "totalAssets": number,
    "totalLiability": number,
    "netBalance": number
  }
}

CODE CONSTRAINTS
- Use existing MSSQL pool from services/db.js
- No new auth logic
- No duplicated queries
- No joins
- No frontend assumptions

SELECT
  ISNULL(ShrsBal, 0)       AS shares,
  ISNULL(SavingBal, 0)     AS ordinarySavings,
  ISNULL(BuildBal, 0)      AS refundAccount,
  ISNULL(SpeSavBal, 0)     AS rssAccount,
  ISNULL(EssenCoRepBal, 0) AS commodityAccount,
  ISNULL(DevBal, 0)        AS developmentLevy,
  ISNULL(LoanRepBal, 0)    AS loans
FROM Pix_Table
WHERE AdNo = @pl


## PERSONAL PROFILE ENDPOINT (READ-ONLY)

Purpose:
Expose a member’s personal profile data for the mobile app.
This endpoint is READ-ONLY and must NEVER modify data.

Endpoint:
GET /api/profile

Authentication:
- JWT REQUIRED
- Extract PL strictly from req.user.pl
- NEVER accept PL from request params, query, or body

Database:
- MSSQL ONLY
- Table: Individual_Personal_Data_Table
- Match condition: IndivID = @pl
- Use parameterized queries via services/db.js

Returned Fields (DB → API mapping):
- Title                → title
- Surname              → surname
- OtherNames           → otherNames
- Date_Birth           → dateOfBirth
- Sex                  → sex
- AdmisDate            → admissionDate
- Occupation           → occupation
- PermanetHomeAdd      → permanentHomeAddress
- emailAdd             → email
- PhoneNo              → phone
- RegistrationNo       → registrationNo
- Next_Kin             → nextOfKin
- MDA                  → mda
- CourseOfStudy        → courseOfStudy
- ServiceArea          → serviceArea
- NOKName              → nokName
- NOKPhoneNo           → nokPhone

Response Format:
{
  success: true,
  data: {
    title,
    surname,
    otherNames,
    dateOfBirth,
    sex,
    admissionDate,
    occupation,
    permanentHomeAddress,
    email,
    phone,
    registrationNo,
    nextOfKin,
    mda,
    courseOfStudy,
    serviceArea,
    nokName,
    nokPhone
  }
}

Error Handling:
- If no record found → return 404
- Do NOT leak DB errors
- Do NOT expose table or column names

Constraints:
- NO joins
- NO updates/inserts
- NO formatting or transformations
- Return raw DB values only
- One record per PL

Structure:
- Route file: routes/profile.js
- Mount in index.js under /api/profile



## ACCOUNT SUMMARY ENDPOINT (READ-ONLY)

Purpose:
Provide a compact financial summary for a member.
Used for overview cards and quick insights.

Endpoint:
GET /api/account-summary

Authentication:
- JWT REQUIRED
- Extract PL strictly from req.user.pl
- NEVER accept PL from params, query, or body

Database:
- MSSQL ONLY
- Table: Pix_Table
- Match condition: AdNo = @pl
- Use parameterized queries via services/db.js
- Single query only

Column Mapping (DB → API):
- Shares → ShrBal
- OrdinarySavings → SavingBal
- RefundAccount → BuildBal
- RSSAccount → SpeSavBal
- CommodityAccount → EssenCoRepBal
- DevelopmentLevy → DevBal
- Loans → LoanRepBal

Backend Calculations:
- totalAssets =
  Shares +
  OrdinarySavings +
  RefundAccount +
  RSSAccount

- totalLiability =
  Loans +
  CommodityAccount

- netBalance =
  totalAssets - totalLiability

Response Format:
{
  success: true,
  data: {
    shares,
    ordinarySavings,
    refundAccount,
    rssAccount,
    commodityAccount,
    developmentLevy,
    loans,
    totalAssets,
    totalLiability,
    netBalance
  }
}

Constraints:
- Numbers only (no strings)
- Use ISNULL for all balances
- No raw DB column names in response
- No joins
- No mutations
- One record per PL

Structure:
- Route file: routes/accountSummary.js
- Mount path: /api/account-summary


## LOAN PORTFOLIO ENDPOINT (READ-ONLY)

Purpose:
Expose a member’s full loan portfolio, including historical and active loan data,
current reducing balance state, and loan metadata.

Endpoint:
GET /api/loan-portfolio

Authentication:
- JWT REQUIRED
- Extract PL strictly from req.user.pl
- NEVER accept PL from params, query, or body

Primary Tables:
1. Loan_Record_Table
   - Borrower'sID = @pl

2. Loan_Reducing_Balance_Analysis_Table
   - BorrowerID = @pl

3. Loan_Types_Table
   - Join via loan type name (LnTyp → TypeName)

Database Rules:
- MSSQL ONLY
- Parameterized queries via services/db.js
- Multiple queries allowed
- NO writes, NO updates, NO deletes

------------------------------------
Loan_Record_Table → API Mapping:
------------------------------------
- AmountRequired        → amountRequested
- AmountApproved        → amountApproved
- TransactionDate       → transactionDate
- InterestRate          → monthlyInterestRate
- TotalInterest         → totalInterest
- Paid                  → fullyPaid (boolean)
- PymtDrtn              → paymentDurationMonths
- LnRtrn                → monthlyRepaymentAmount
- IntRtrn               → monthlyInterestReturn
- LnTyp                 → loanType
- Purpose_Loan          → loanPurpose
- DateOfCompletion      → completionDate

------------------------------------
Loan_Reducing_Balance_Analysis_Table → API Mapping:
------------------------------------
- TransDate             → lastTransactionDate
- CurrBal               → currentOutstandingBalance
- NextInt               → nextInterestBalance
- LoanRepayment         → amountPaidToDate

------------------------------------
Loan_Types_Table → API Mapping:
------------------------------------
- TypeName              → loanType
- Rate                  → loanTypeRate

------------------------------------
Derived / Calculated Fields:
------------------------------------
- totalLoanAmount = amountApproved + totalInterest
- outstandingLoan = currentOutstandingBalance
- loanStatus:
    - "FULLY_PAID" if fullyPaid = 1
    - "ACTIVE" if fullyPaid = 0 AND currentOutstandingBalance > 0
    - "COMPLETED" if completionDate IS NOT NULL

------------------------------------
Response Format:
------------------------------------
{
  success: true,
  data: [
    {
      loanType,
      loanTypeRate,
      loanPurpose,
      amountRequested,
      amountApproved,
      totalLoanAmount,
      totalInterest,
      monthlyInterestRate,
      monthlyRepaymentAmount,
      paymentDurationMonths,
      amountPaidToDate,
      currentOutstandingBalance,
      nextInterestBalance,
      loanStatus,
      transactionDate,
      lastTransactionDate,
      completionDate
    }
  ]
}

------------------------------------
Constraints:
------------------------------------
- Return array (even if one loan)
- Numbers only (no strings)
- Dates as raw DB dates
- No joins that modify cardinality
- No frontend assumptions
- No pagination in v1

------------------------------------
Structure:
------------------------------------
- Route file: routes/loanPortfolio.js
- Mount path: /api/loan-portfolio
